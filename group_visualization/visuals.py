"""Tools for analyzing normalization output."""
import math
from typing import Tuple, Dict, Optional, List

import plotly.graph_objects as go
import networkx as nx
from therapy.query import QueryHandler
from therapy.schemas import MatchType, UnmergedNormalizationService


def get_graph_positions(
    response: UnmergedNormalizationService,
) -> Tuple[nx.classes.graph.Graph, Dict]:
    """
    Generate node positions for graph using Kamada-Kawai algorithm.
    :param response: successful response from normalize_unmerged method.
    :return: networkx Graph object and positions Dict
    """
    edges = []
    nodes = set()
    for source in response.source_matches.values():
        for record in source.records:
            nodes.add(record.concept_id)
            for ref in record.xrefs:  # type: ignore
                edges.append((record.concept_id, ref))
    edges = [(e1, e2) for (e1, e2) in edges if e1 in nodes and e2 in nodes]

    G = nx.Graph()
    for (e1, e2) in edges:
        G.add_edge(e1, e2)
    return G, nx.kamada_kawai_layout(G)


def get_centrality_scatter(pos: Dict) -> go.Scatter:
    """
    Construct scatter plot for graph nodes demonstrating centrality
    :param pos: positions generated by Kamada-Kawai algorithm.
    :return: scatter object
    """
    node_x = [v[0] for v in pos.values()]
    node_y = [v[1] for v in pos.values()]
    node_trace = go.Scatter(
        x=node_x,
        y=node_y,
        mode="markers",
        hoverinfo="text",
        marker=dict(
            showscale=True,
            colorscale="geyser",
            reversescale=True,
            color=[],
            size=10,
            colorbar=dict(
                thickness=15,
                title="Betweenness Centrality",
                xanchor="left",
                titleside="right",
            ),
            line_width=2,
        ),
    )
    return node_trace


def get_source_scatter(
    response: UnmergedNormalizationService, pos: Dict
) -> List[go.Scatter]:
    """
    Construct scatter object demonstrating source distribution in graph.
    :param response: successful response from normalize_unmerged method.
    :param pos: positions generated by Kamada-Kawai algorithm.
    :return: List of scatter traces with nodes colored by source
    """
    source_lookup = {}
    for source, source_result in response.source_matches.items():
        # x coords, y coords, (label, concept ID)
        source_coords = ([], [], [])
        for record in source_result.records:
            if record.concept_id in pos:
                source_coords[0].append(pos[record.concept_id][0])
                source_coords[1].append(pos[record.concept_id][1])
                source_coords[2].append((record.label, record.concept_id))
        if len(source_coords[0]):
            source_lookup[source.value] = source_coords

    data = []
    for source, coords in source_lookup.items():
        trace = go.Scatter(
            x=coords[0],
            y=coords[1],
            mode="markers",
            name=source,
            hoverinfo="text",
            marker=dict(size=30, line_width=2),
        )
        trace.text = [
            f"ID: {record[1]}<br />Label: {record[0]}" for record in coords[2]
        ]
        data.append(trace)
    return data


def scale_edge_points(
    x_1: float, y_1: float, x_2: float, y_2: float, radius: float
) -> Tuple[float, float]:
    """Scale coordinates to ensure that xref arrows don't overlap
    :param x_1: x coordinate of first end
    :param y_1: y coordinate of first end
    :param x_2: x coordinate of second end
    :param y_2: y coordinate of second end
    :param radius: approximation of point radius to scale away
    :return: scaled set of coordinates
    """
    d = math.sqrt((y_2 - y_1) ** 2 + (x_2 - x_1) ** 2)
    x_prime = radius * (x_2 - x_1) / d
    y_prime = radius * (y_2 - y_1) / d
    return (x_prime + x_1, y_prime + y_1)


def add_edges(
    G: nx.classes.graph.Graph, pos: Dict, fig: go.Figure, radius: float = 0.01
) -> go.Figure:
    """
    Add scaled edges to figure.
    :param G: Networkx graph object with edges
    :param pos: positions map
    :param fig: Plotly figure
    :param radius: value to scale edges by, to avoid collision with scatter dots
    :return: Updated figure
    """
    for start, end in G.edges():
        x_1, y_1 = pos[start]
        x_2, y_2 = pos[end]
        x_1_p, y_1_p = scale_edge_points(x_1, y_1, x_2, y_2, radius)
        x_2_p, y_2_p = scale_edge_points(x_2, y_2, x_1, y_1, radius)
        fig.add_annotation(
            x=x_1_p,
            y=y_1_p,
            ax=x_2_p,
            ay=y_2_p,
            xref="x",
            yref="y",
            axref="x",
            ayref="y",
            text="",
            showarrow=True,
            arrowhead=1,
            arrowsize=2,
            arrowwidth=1,
            arrowcolor="black",
        )
    return fig


def build_figure(data: List[go.Scatter], title: str, showlegend: bool) -> go.Figure:
    """
    Construct central figure object.
    :param data: traces to provide as data to figure
    :param title: title of figure
    :param showlegend: if true, legend should be displayed to the right
    :return: completed figure object
    """
    return go.Figure(
        data=data,
        layout=go.Layout(
            title=title,
            titlefont_size=16,
            showlegend=showlegend,
            hovermode="closest",
            margin=dict(b=20, l=5, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        ),
    )


def draw_centrality_graph(q: QueryHandler, drug_term: str) -> Optional[go.Figure]:
    """Draw visualization of record centrality and relationships under normalized term.
    :param q: handler to process query
    :param drug_term: term to search for
    :return: Plotly figure object if successful. If in a console, will launch a
    Plotly service in the default web browser.
    """
    response = q.normalize_unmerged(drug_term)
    if response.match_type == MatchType.NO_MATCH:
        return None
    G, pos = get_graph_positions(response)
    node_trace = get_centrality_scatter(pos)

    records = {}
    for source in response.source_matches.values():
        for record in source.records:
            records[record.concept_id] = record

    node_trace.marker.color = list(nx.betweenness_centrality(G).values())
    node_trace.text = [f"ID: {n}<br />Label: {records[n].label}" for n in G.nodes()]

    list(G.nodes())

    fig = build_figure(
        [node_trace], f'"{drug_term}" Normalized Group Centrality', False
    )
    fig = add_edges(G, pos, fig)
    fig.update_layout(width=700, height=700)
    fig.show()
    return fig


def draw_source_graph(q: QueryHandler, drug_term: str) -> Optional[go.Figure]:
    """Draw visualization of record sourcing and relationships under normalized term.
    :param q: handler to process query
    :param drug_term: term to search for
    :return: Plotly figure object if successful. If in a console, will launch a
    Plotly service in the default web browser.
    """
    response = q.normalize_unmerged(drug_term)
    G, pos = get_graph_positions(response)

    data = get_source_scatter(response, pos)
    fig = build_figure(data, f'"{drug_term}" Normalized Group by Source', True)

    fig = add_edges(G, pos, fig, 0.052)
    fig.update_layout(width=700, height=700)
    fig.show()
    return fig
